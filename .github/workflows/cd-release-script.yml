name: Build and Docker release

on:
  workflow_call: #불렀을 때만 사용
    inputs: #인자
      service-name: #서비스 이름
        required: true
        type: string
    outputs: #반환값
      tag_name:
        value: ${{ jobs.tagging.outputs.tag_name }}

env:
  DOCKER: docker.io

jobs:
  # =====================================================================
  # [Job 1] 태깅 및 릴리즈 노트 생성
  # 업데이트 시 이미지 태그 충돌을 막기 위해 랜덤 문자열(예: a3f9c1d2)을 생성하고,
  # 이를 기반으로 GitHub Release를 자동 생성하는 단계입니다.
  # =====================================================================
  tagging:
    name: tagging 및 git release
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.tag_version.outputs.new_tag }}
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v5

      - name: versioning and tagging
        id: tag_version #GITHUB_OUTPUT는 반환값 묶음, GITHUB_OUTPUT의 new_tag와 changelog에 값 저장
        run: |
          RANDOM_STR=$(openssl rand -hex 8)  
          echo "Generated random string: $RANDOM_STR"
          echo "new_tag=$RANDOM_STR" >> $GITHUB_OUTPUT 
          echo "changelog=자동 생성된 릴리즈 노트입니다." >> $GITHUB_OUTPUT
        # 예: a3f9c1d2bb44e21f
        # 랜덤인 이유가 업데이트 할때 계속 생성되는데 중복으로 충돌이 없게하기 위함

      - name: releasing # 배포 기록?
        uses: ncipollo/release-action@v1 #git release 해주는 서드파티
        with:
          tag: ${{ steps.tag_version.outputs.new_tag }}
          name: ${{ steps.tag_version.outputs.new_tag }}
          body: ${{ steps.tag_version.outputs.changelog }}

  # =====================================================================
  # [Job 2] 도커 이미지 빌드 및 K3s 배포
  # 코드를 빌드하여 도커 이미지를 만들고 Hub에 푸시한 뒤,
  # 원격 EC2의 K3s 클러스터에 접속하여 알맞은 리소스를 배포하는 핵심 단계입니다.
  # =====================================================================
  build-image:
    name: 도커 이미지 빌드
    runs-on: ubuntu-latest
    needs: tagging #저 job의 반환값을 사용하겠다는 소리 -> tagging 끝나면 돌아간다는 소리

    permissions: #권한
      contents: read
      packages: write
      attestations: write

    steps:
      - name: Check out Repository
        uses: actions/checkout@v5

      # -----------------------------------------------------------------
      # 1. 빌드 환경 세팅 및 도커 레지스트리 로그인
      # -----------------------------------------------------------------
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Sign in github container registry #도커 로그인
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: 메타데이터 작성
        id: meta
        uses: docker/metadata-action@v5
        with: #이미지 이름이랑 메타데이터 작성
          images: ${{ env.DOCKER }}/${{ secrets.DOCKER_USERNAME }}/${{ inputs.service-name }} #docker.io/username/OOOO-service
          # 버전 붙여주는거
          tags: |
            type=sha
            type=raw,value=${{ needs.tagging.outputs.tag_name }}
            type=raw,value=latest

      # -----------------------------------------------------------------
      # 2. 서비스별 설정 파일(YML/PEM) 주입
      # 각 마이크로서비스에 필요한 운영 환경 설정 파일과 보안 키를
      # GitHub Secrets에서 가져와 빌드 전 resources 폴더에 생성합니다.
      # -----------------------------------------------------------------
      - name: account test yml pem 세팅
        if: ${{ inputs.service-name == 'account-service' }}
        run: |
          mkdir -p ./FLOWIN/account-service/src/main/resources
          echo '${{ secrets.ACCOUNT_PROD_YML }}' > ./FLOWIN/account-service/src/main/resources/application-prod.yml
          echo '${{ secrets.PRIVATE_KEY_PEM }}' > ./FLOWIN/account-service/src/main/resources/private-key.pem

      - name: gateway test yml pem 세팅
        if: ${{ inputs.service-name == 'gateway-service' }}
        run: |
          mkdir -p ./FLOWIN/gateway-service/src/main/resources
          echo '${{ secrets.GATEWAY_PROD_YML }}' > ./FLOWIN/gateway-service/src/main/resources/application-prod.yml
          echo '${{ secrets.PUBLIC_KEY_PEM }}' > ./FLOWIN/gateway-service/src/main/resources/public-key.pem

      - name: payment test yml pem 세팅
        if: ${{ inputs.service-name == 'payment-service' }}
        run: |
          mkdir -p ./FLOWIN/payment-service/src/main/resources
          echo '${{ secrets.PAYMENT_PROD_YML }}' > ./FLOWIN/payment-service/src/main/resources/application-prod.yml

      - name: performance test yml pem 세팅
        if: ${{ inputs.service-name == 'performance-service' }}
        run: |
          mkdir -p ./FLOWIN/performance-service/src/main/resources
          echo '${{ secrets.PERFORMANCE_PROD_YML }}' > ./FLOWIN/performance-service/src/main/resources/application-prod.yml

      - name: reservation test yml pem 세팅
        if: ${{ inputs.service-name == 'reservation-service' }}
        run: |
          mkdir -p ./FLOWIN/reservation-service/src/main/resources
          echo '${{ secrets.RESERVATION_PROD_YML }}' > ./FLOWIN/reservation-service/src/main/resources/application-prod.yml

      - name: ai test yml pem 세팅
        if: ${{ inputs.service-name == 'ai-service' }}
        run: |
          mkdir -p ./FLOWIN/ai-service/src/main/resources
          echo '${{ secrets.AI_PROD_YML }}' > ./FLOWIN/ai-service/src/main/resources/application-prod.yml

      # -----------------------------------------------------------------
      # 3. 프로젝트 빌드 및 도커 이미지 푸시
      # 테스트를 건너뛰고(-x test) 빠르게 빌드한 뒤, 앞서 만든 메타데이터 태그를 붙여
      # Docker Hub에 이미지를 업로드합니다.
      # -----------------------------------------------------------------
      - name: Build with Gradle
        working-directory: ./FLOWIN/${{ inputs.service-name }}
        env: # <--- 로봇에게 깃허브 패키지 출입증(토큰) 발급!
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          chmod +x gradlew
          ./gradlew clean build -x test
        # 이미 CI에서는 테스트가 마무리 되었을테니 -x test를 통해 테스트 스킵하고 빌드

      - name: Push Image #빌드하고 푸시
        uses: docker/build-push-action@v6
        with:
          context: ./FLOWIN/${{ inputs.service-name }} # 빌드에 필요한 소스 코드가 위치한 경로
          file: ./FLOWIN/${{ inputs.service-name }}/Dockerfile #  이미지를 만드는 설계도인 Dockerfile의 정확한 위치
          push: true # 빌드가 완료된 후, 결과물(이미지)을 지정된 레지스트리에 즉시 업로드
          tags: ${{ steps.meta.outputs.tags }} # 이미지의 버전 이름(예: v1.0.0, latest)을 지정
          labels: ${{ steps.meta.outputs.labels }} # 이미지에 메타데이터(제작자, 빌드 날짜 등)를 추가 < 부가 정보

      # -----------------------------------------------------------------
      # 4. K3s 원격 접속 및 기초 설정(Namespace, Secret)
      # kubectl을 설치하고 KUBE_CONFIG로 EC2에 연결한 뒤,
      # 공통적으로 필요한 DB 비밀번호 등의 Secret을 멱등성 있게 배포합니다.
      # -----------------------------------------------------------------
      # kubectl 도구 설치
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # 클러스터 연결 (Secrets에 KUBE_CONFIG 등록 필수!)
      - name: Configure Kubernetes Context
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      # 기초 공사 (Namespace & Secret)
      #    어떤 서비스가 배포되든 이 설정은 항상 체크 (없으면 생성, 있으면 패스)
      - name: Ensure Namespace and Secrets
        run: |
          kubectl create namespace flowin --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl create secret generic db-secret \
            --namespace flowin \
            --from-literal=password="${{ secrets.DB_PASSWORD }}" \
            --from-literal=redis-password="${{ secrets.REDIS_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl create secret generic elastic-credentials \
            --namespace flowin \
            --from-literal=password="${{ secrets.ELASTIC_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      # -----------------------------------------------------------------
      # 5. 분기 배포 (Gateway vs 일반 마이크로서비스)
      # Gateway 배포 시에는 인프라(DB, MQ, ELK 등) 공통 설정까지 함께 배포하고,
      # 일반 서비스일 경우 해당 서비스의 파드만 배포합니다.
      # -----------------------------------------------------------------
      # [조건부 배포 A] Gateway일 때 -> 전체 인프라(Config, Outer) + 게이트웨이 배포
      - name: Deploy Infrastructure & Gateway
        if: ${{ inputs.service-name == 'gateway-service' }}
        run: |
          echo "Deploying Configurations and PVCs..."
          kubectl apply -f k3s/exec/config/db/
          kubectl apply -f k3s/exec/config/mq/
          kubectl apply -f k3s/exec/config/elk/
          kubectl apply -f k3s/exec/config/gateway/

          echo "Deploying Infrastructure (DB, MQ, ELK, LB)..."
          kubectl apply -f k3s/exec/outer/db/
          kubectl apply -f k3s/exec/outer/mq/
          kubectl apply -f k3s/exec/outer/elk/
          kubectl apply -f k3s/exec/outer/lb/
          kubectl apply -f k3s/exec/outer/zipkin/
          
          echo "Deploying Gateway Service..."
          kubectl apply -f k3s/exec/inner/gateway-service/

      # [조건부 배포 B] 일반 서비스일 때 -> 해당 서비스만 배포
      - name: Deploy Microservice
        if: ${{ inputs.service-name != 'gateway-service' }}
        run: |
          echo "Deploying ${{ inputs.service-name }}..."
          # K8s YAML 파일 경로 수정 (exec/inner/...)
          kubectl apply -f k3s/exec/inner/${{ inputs.service-name }}/

      # -----------------------------------------------------------------
      # 6. 파드 재시작(Rollout)
      # 이미지가 latest로 동일하더라도 K3s가 새 이미지를 당겨오도록
      # 기존 파드를 안전하게 껐다 켜는 무중단 롤아웃을 수행합니다.
      # -----------------------------------------------------------------
      - name: Rollout Restart
        run: |
          echo "Checking deployment status..."
          
          if kubectl get deployment ${{ inputs.service-name }} -n flowin > /dev/null 2>&1; then
            echo "Deployment found. Restarting pods to pull new image..."
            kubectl rollout restart deployment/${{ inputs.service-name }} -n flowin
            kubectl rollout status deployment/${{ inputs.service-name }} -n flowin --timeout=240s
          else
            echo "⚠️ Deployment not found. Skipping rollout restart (This might be the first deploy)."
          fi