name: image deploy

on:
  workflow_call: #불렀을 때만 사용
    inputs: #인자
      service-name: #서비스 이름
        required: true
        type: string

env:
  DOCKER: docker.io

jobs:
  # Job 3. K3s 배포
  # 원격 EC2의 K3s 클러스터에 접속하여 알맞은 리소스를 배포하는 핵심 단계입니다.
  image-deploy:
    name: K3s 배포
    runs-on: self-hosted

    permissions: #권한
      contents: read
      packages: write
      attestations: write

    steps:
      - name: Check out Repository
        uses: actions/checkout@v5

      # 1. K3s 원격 접속 및 기초 설정(Namespace, Secret)
      # kubectl을 설치하고 KUBE_CONFIG로 EC2에 연결한 뒤,
      # 공통적으로 필요한 DB 비밀번호 등의 Secret을 멱등성 있게 배포합니다.
      # kubectl 도구 설치
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # 클러스터 연결 (Secrets에 KUBE_CONFIG 등록 필수)
      - name: Configure Kubernetes Context
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      # 기초 공사 (Namespace & Secret)
      # 어떤 서비스가 배포되든 이 설정은 항상 체크 (없으면 생성, 있으면 패스)
      - name: Ensure Namespace and Secrets
        run: |
          kubectl create namespace flowin --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl create secret generic db-secret \
            --namespace flowin \
            --from-literal=password="${{ secrets.DB_PASSWORD }}" \
            --from-literal=redis-password="${{ secrets.REDIS_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl create secret generic elastic-credentials \
            --namespace flowin \
            --from-literal=password="${{ secrets.ELASTIC_PASSWORD }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      # 2. 분기 배포 (Gateway vs 일반 마이크로서비스)
      # Gateway 배포 시에는 인프라(DB, MQ, ELK 등) 공통 설정까지 함께 배포하고,
      # 일반 서비스일 경우 해당 서비스의 파드만 배포합니다.

      # [조건부 배포 A] Gateway일 때 -> 전체 인프라(Config, Outer) + 게이트웨이 배포
      - name: Deploy Infrastructure & Gateway
        if: ${{ inputs.service-name == 'gateway-service' }}
        run: |
          echo "Deploying Configurations and PVCs..."
          kubectl apply -f k3s/exec/config/db/
          kubectl apply -f k3s/exec/config/mq/
          kubectl apply -f k3s/exec/config/elk/
          kubectl apply -f k3s/exec/config/gateway/

          echo "Deploying Infrastructure (DB, MQ, ELK, LB)..."
          kubectl apply -f k3s/exec/outer/db/
          kubectl apply -f k3s/exec/outer/mq/
          kubectl apply -f k3s/exec/outer/elk/
          kubectl apply -f k3s/exec/outer/lb/
          kubectl apply -f k3s/exec/outer/zipkin/
          
          echo "Deploying Gateway Service..."
          kubectl apply -f k3s/exec/inner/gateway-service/

      # [조건부 배포 B] 일반 서비스일 때 -> 해당 서비스만 배포
      - name: Deploy Microservice
        if: ${{ inputs.service-name != 'gateway-service' }}
        run: |
          echo "Deploying ${{ inputs.service-name }}..."
          # K8s YAML 파일 경로 수정 (exec/inner/...)
          kubectl apply -f k3s/exec/inner/${{ inputs.service-name }}/

      # 3. 파드 재시작(Rollout)
      # 이미지가 latest로 동일하더라도 K3s가 새 이미지를 당겨오도록
      # 기존 파드를 안전하게 껐다 켜는 무중단 롤아웃을 수행합니다.
      - name: Rollout Restart
        run: |
          echo "Checking deployment status..."
          
          if kubectl get deployment ${{ inputs.service-name }} -n flowin > /dev/null 2>&1; then
            echo "Deployment found. Restarting pods to pull new image..."
            kubectl rollout restart deployment/${{ inputs.service-name }} -n flowin
            kubectl rollout status deployment/${{ inputs.service-name }} -n flowin --timeout=240s
          else
            echo "Deployment not found. Skipping rollout restart (This might be the first deploy)."
          fi